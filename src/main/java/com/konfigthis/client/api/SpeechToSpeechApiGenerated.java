/*
 * ElevenLabs API Documentation
 * This is the documentation for the ElevenLabs API. You can use this API to use our service programmatically, this is done by using your xi-api-key. <br/> You can view your xi-api-key using the 'Profile' tab on https://elevenlabs.io. Our API is experimental so all endpoints are subject to change.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost;
import com.konfigthis.client.model.BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost;
import java.io.File;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class SpeechToSpeechApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public SpeechToSpeechApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public SpeechToSpeechApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call createWithVoiceCall(String voiceId, File audio, BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost, Integer optimizeStreamingLatency, String xiApiKey, String modelId, String voiceSettings, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost;

        // create path and map variables
        String localVarPath = "/v1/speech-to-speech/{voice_id}"
            .replace("{" + "voice_id" + "}", localVarApiClient.escapeString(voiceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (audio != null) {
            localVarFormParams.put("audio", audio);
        }

        if (modelId != null) {
            localVarFormParams.put("model_id", modelId);
        }

        if (voiceSettings != null) {
            localVarFormParams.put("voice_settings", voiceSettings);
        }

        if (optimizeStreamingLatency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("optimize_streaming_latency", optimizeStreamingLatency));
        }

        if (xiApiKey != null) {
            localVarHeaderParams.put("xi-api-key", localVarApiClient.parameterToString(xiApiKey));
        }

        final String[] localVarAccepts = {
            "audio/mpeg",
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createWithVoiceValidateBeforeCall(String voiceId, File audio, BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost, Integer optimizeStreamingLatency, String xiApiKey, String modelId, String voiceSettings, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'voiceId' is set
        if (voiceId == null) {
            throw new ApiException("Missing the required parameter 'voiceId' when calling createWithVoice(Async)");
        }

        // verify the required parameter 'audio' is set
        if (audio == null) {
            throw new ApiException("Missing the required parameter 'audio' when calling createWithVoice(Async)");
        }

        // verify the required parameter 'bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost' is set
        if (bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost == null) {
            throw new ApiException("Missing the required parameter 'bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost' when calling createWithVoice(Async)");
        }

        return createWithVoiceCall(voiceId, audio, bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings, _callback);

    }


    private ApiResponse<Void> createWithVoiceWithHttpInfo(String voiceId, File audio, BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost, Integer optimizeStreamingLatency, String xiApiKey, String modelId, String voiceSettings) throws ApiException {
        okhttp3.Call localVarCall = createWithVoiceValidateBeforeCall(voiceId, audio, bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call createWithVoiceAsync(String voiceId, File audio, BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost, Integer optimizeStreamingLatency, String xiApiKey, String modelId, String voiceSettings, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = createWithVoiceValidateBeforeCall(voiceId, audio, bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class CreateWithVoiceRequestBuilder {
        private final String voiceId;
        private final File audio;
        private Integer optimizeStreamingLatency;
        private String xiApiKey;
        private String modelId;
        private String voiceSettings;

        private CreateWithVoiceRequestBuilder(String voiceId, File audio) {
            this.voiceId = voiceId;
            this.audio = audio;
        }

        /**
         * Set optimizeStreamingLatency
         * @param optimizeStreamingLatency You can turn on latency optimizations at some cost of quality. The best possible final latency varies by model. Possible values: 0 - default mode (no latency optimizations) 1 - normal latency optimizations (about 50% of possible latency improvement of option 3) 2 - strong latency optimizations (about 75% of possible latency improvement of option 3) 3 - max latency optimizations 4 - max latency optimizations, but also with text normalizer turned off for even more latency savings (best latency, but can mispronounce eg numbers and dates).  Defaults to 0.  (optional, default to 0)
         * @return CreateWithVoiceRequestBuilder
         */
        public CreateWithVoiceRequestBuilder optimizeStreamingLatency(Integer optimizeStreamingLatency) {
            this.optimizeStreamingLatency = optimizeStreamingLatency;
            return this;
        }
        
        /**
         * Set xiApiKey
         * @param xiApiKey Your API key. This is required by most endpoints to access our API programatically. You can view your xi-api-key using the &#39;Profile&#39; tab on the website. (optional)
         * @return CreateWithVoiceRequestBuilder
         */
        public CreateWithVoiceRequestBuilder xiApiKey(String xiApiKey) {
            this.xiApiKey = xiApiKey;
            return this;
        }
        
        /**
         * Set modelId
         * @param modelId Identifier of the model that will be used, you can query them using GET /v1/models. The model needs to have support for speech to speech, you can check this using the can_do_voice_conversion property. (optional, default to eleven_english_sts_v2)
         * @return CreateWithVoiceRequestBuilder
         */
        public CreateWithVoiceRequestBuilder modelId(String modelId) {
            this.modelId = modelId;
            return this;
        }
        
        /**
         * Set voiceSettings
         * @param voiceSettings Voice settings overriding stored setttings for the given voice. They are applied only on the given request. Needs to be send as a JSON encoded string. (optional)
         * @return CreateWithVoiceRequestBuilder
         */
        public CreateWithVoiceRequestBuilder voiceSettings(String voiceSettings) {
            this.voiceSettings = voiceSettings;
            return this;
        }
        
        /**
         * Build call for createWithVoice
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost = buildBodyParams();
            return createWithVoiceCall(voiceId, audio, bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings, _callback);
        }

        private BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost buildBodyParams() {
            BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost = new BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost();
            bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost.audio(this.audio);
            bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost.modelId(this.modelId);
            bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost.voiceSettings(this.voiceSettings);
            return bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost;
        }

        /**
         * Execute createWithVoice request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost = buildBodyParams();
            createWithVoiceWithHttpInfo(voiceId, audio, bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings);
        }

        /**
         * Execute createWithVoice request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost = buildBodyParams();
            return createWithVoiceWithHttpInfo(voiceId, audio, bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings);
        }

        /**
         * Execute createWithVoice request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost = buildBodyParams();
            return createWithVoiceAsync(voiceId, audio, bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings, _callback);
        }
    }

    /**
     * Speech To Speech
     * Create speech by combining the content and emotion of the uploaded audio with a voice of your choice.
     * @param voiceId Voice ID to be used, you can use https://api.elevenlabs.io/v1/voices to list all the available voices. (required)
     * @param audio The audio file which holds the content and emotion that will control the generated speech. (required)
     * @param bodySpeechToSpeechV1SpeechToSpeechVoiceIdPost  (required)
     * @return CreateWithVoiceRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public CreateWithVoiceRequestBuilder createWithVoice(String voiceId, File audio) throws IllegalArgumentException {
        if (voiceId == null) throw new IllegalArgumentException("\"voiceId\" is required but got null");
            

        if (audio == null) throw new IllegalArgumentException("\"audio\" is required but got null");
        return new CreateWithVoiceRequestBuilder(voiceId, audio);
    }
    private okhttp3.Call createWithVoice_0Call(String voiceId, File audio, BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost, Integer optimizeStreamingLatency, String xiApiKey, String modelId, String voiceSettings, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost;

        // create path and map variables
        String localVarPath = "/v1/speech-to-speech/{voice_id}/stream"
            .replace("{" + "voice_id" + "}", localVarApiClient.escapeString(voiceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (audio != null) {
            localVarFormParams.put("audio", audio);
        }

        if (modelId != null) {
            localVarFormParams.put("model_id", modelId);
        }

        if (voiceSettings != null) {
            localVarFormParams.put("voice_settings", voiceSettings);
        }

        if (optimizeStreamingLatency != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("optimize_streaming_latency", optimizeStreamingLatency));
        }

        if (xiApiKey != null) {
            localVarHeaderParams.put("xi-api-key", localVarApiClient.parameterToString(xiApiKey));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "multipart/form-data"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createWithVoice_0ValidateBeforeCall(String voiceId, File audio, BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost, Integer optimizeStreamingLatency, String xiApiKey, String modelId, String voiceSettings, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'voiceId' is set
        if (voiceId == null) {
            throw new ApiException("Missing the required parameter 'voiceId' when calling createWithVoice_0(Async)");
        }

        // verify the required parameter 'audio' is set
        if (audio == null) {
            throw new ApiException("Missing the required parameter 'audio' when calling createWithVoice_0(Async)");
        }

        // verify the required parameter 'bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost' is set
        if (bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost == null) {
            throw new ApiException("Missing the required parameter 'bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost' when calling createWithVoice_0(Async)");
        }

        return createWithVoice_0Call(voiceId, audio, bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings, _callback);

    }


    private ApiResponse<Void> createWithVoice_0WithHttpInfo(String voiceId, File audio, BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost, Integer optimizeStreamingLatency, String xiApiKey, String modelId, String voiceSettings) throws ApiException {
        okhttp3.Call localVarCall = createWithVoice_0ValidateBeforeCall(voiceId, audio, bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call createWithVoice_0Async(String voiceId, File audio, BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost, Integer optimizeStreamingLatency, String xiApiKey, String modelId, String voiceSettings, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = createWithVoice_0ValidateBeforeCall(voiceId, audio, bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class CreateWithVoice0RequestBuilder {
        private final String voiceId;
        private final File audio;
        private Integer optimizeStreamingLatency;
        private String xiApiKey;
        private String modelId;
        private String voiceSettings;

        private CreateWithVoice0RequestBuilder(String voiceId, File audio) {
            this.voiceId = voiceId;
            this.audio = audio;
        }

        /**
         * Set optimizeStreamingLatency
         * @param optimizeStreamingLatency You can turn on latency optimizations at some cost of quality. The best possible final latency varies by model. Possible values: 0 - default mode (no latency optimizations) 1 - normal latency optimizations (about 50% of possible latency improvement of option 3) 2 - strong latency optimizations (about 75% of possible latency improvement of option 3) 3 - max latency optimizations 4 - max latency optimizations, but also with text normalizer turned off for even more latency savings (best latency, but can mispronounce eg numbers and dates).  Defaults to 0.  (optional, default to 0)
         * @return CreateWithVoice0RequestBuilder
         */
        public CreateWithVoice0RequestBuilder optimizeStreamingLatency(Integer optimizeStreamingLatency) {
            this.optimizeStreamingLatency = optimizeStreamingLatency;
            return this;
        }
        
        /**
         * Set xiApiKey
         * @param xiApiKey Your API key. This is required by most endpoints to access our API programatically. You can view your xi-api-key using the &#39;Profile&#39; tab on the website. (optional)
         * @return CreateWithVoice0RequestBuilder
         */
        public CreateWithVoice0RequestBuilder xiApiKey(String xiApiKey) {
            this.xiApiKey = xiApiKey;
            return this;
        }
        
        /**
         * Set modelId
         * @param modelId Identifier of the model that will be used, you can query them using GET /v1/models. The model needs to have support for speech to speech, you can check this using the can_do_voice_conversion property. (optional, default to eleven_english_sts_v2)
         * @return CreateWithVoice0RequestBuilder
         */
        public CreateWithVoice0RequestBuilder modelId(String modelId) {
            this.modelId = modelId;
            return this;
        }
        
        /**
         * Set voiceSettings
         * @param voiceSettings Voice settings overriding stored setttings for the given voice. They are applied only on the given request. Needs to be send as a JSON encoded string. (optional)
         * @return CreateWithVoice0RequestBuilder
         */
        public CreateWithVoice0RequestBuilder voiceSettings(String voiceSettings) {
            this.voiceSettings = voiceSettings;
            return this;
        }
        
        /**
         * Build call for createWithVoice_0
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost = buildBodyParams();
            return createWithVoice_0Call(voiceId, audio, bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings, _callback);
        }

        private BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost buildBodyParams() {
            BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost = new BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost();
            bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost.audio(this.audio);
            bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost.modelId(this.modelId);
            bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost.voiceSettings(this.voiceSettings);
            return bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost;
        }

        /**
         * Execute createWithVoice_0 request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost = buildBodyParams();
            createWithVoice_0WithHttpInfo(voiceId, audio, bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings);
        }

        /**
         * Execute createWithVoice_0 request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost = buildBodyParams();
            return createWithVoice_0WithHttpInfo(voiceId, audio, bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings);
        }

        /**
         * Execute createWithVoice_0 request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost = buildBodyParams();
            return createWithVoice_0Async(voiceId, audio, bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost, optimizeStreamingLatency, xiApiKey, modelId, voiceSettings, _callback);
        }
    }

    /**
     * Speech To Speech Streaming
     * Create speech by combining the content and emotion of the uploaded audio with a voice of your choice and returns an audio stream.
     * @param voiceId Voice ID to be used, you can use https://api.elevenlabs.io/v1/voices to list all the available voices. (required)
     * @param audio The audio file which holds the content and emotion that will control the generated speech. (required)
     * @param bodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost  (required)
     * @return CreateWithVoice0RequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
     </table>
     */
    public CreateWithVoice0RequestBuilder createWithVoice_0(String voiceId, File audio) throws IllegalArgumentException {
        if (voiceId == null) throw new IllegalArgumentException("\"voiceId\" is required but got null");
            

        if (audio == null) throw new IllegalArgumentException("\"audio\" is required but got null");
        return new CreateWithVoice0RequestBuilder(voiceId, audio);
    }
}
